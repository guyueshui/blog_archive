<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="瞎说 KMP 算法"><meta name="keywords" content="algorithm,pattern match,string match"><meta name="author" content="Yychi,guyueshui002@gmail.com"><meta name="copyright" content="Yychi"><title>瞎说 KMP 算法 | 水阙</title><link rel="shortcut icon" href="/cali.png"><link rel="stylesheet" href="/css/index.css?version=1.6.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.0"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?a37e52e4ac68b7bedc09537444f68899";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-132747551-1', 'auto');
ga('send', 'pageview');</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#背景"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常规方法"><span class="toc-number">2.</span> <span class="toc-text">常规方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Partial-Match-Table"><span class="toc-number">3.</span> <span class="toc-text">Partial Match Table</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#又"><span class="toc-number">3.1.</span> <span class="toc-text">又</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PMT-怎么用"><span class="toc-number">4.</span> <span class="toc-text">PMT 怎么用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复杂度分析"><span class="toc-number">5.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-实现"><span class="toc-number">6.</span> <span class="toc-text">C++实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number">7.</span> <span class="toc-text">Reference</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://guyueshui.github.io/assets/avatar.png"></div><div class="author-info__name text-center">Yychi</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">33</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">34</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">3</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://ruanzz.github.io">Ryan's Blog</a><a class="author-info-links__name text-center" href="http://www.matrix67.com/blog/">Matrix67</a><a class="author-info-links__name text-center" href="/links">More...</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s2.ax1x.com/2019/02/19/kgD6g0.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">水阙</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/sketch">札记</a><a class="site-page" href="/tricks">Tricks</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">瞎说 KMP 算法</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-04</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Learning-Notes/">Learning Notes</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>前天做百度笔试，没想到居然出往年的题！哼！更惨的是出了我也不会！我以为只是一个简简单单的字符串匹配，没想到要动用这么难懂的算法。说起来算法导论上也有，只是之前没看到那里。所以，总结一下：我本有好多次机会学习它，然而一次都没有把握。:(</p>
<p>所以这次，拿出来好好研究一波，做点笔记，以备日后之用。说起来网络上关于该算法的博文一大堆，我也不说能比它们都好，每个人都有适合自己的理解，我这里就是瞎谈一番罢了。</p>
<p>在开始之前，强烈建议先读<a href="http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/" target="_blank" rel="noopener">Jake Boxer</a>的文章，它从无到有，讲得浅显易懂，介绍了 how it works！我这篇文章，也是在看了好多中文博客未解之后，开始看了那个外文博文。在理解的基础上，加一点自己的描述。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>长长的博文一大堆，相信你也很珍惜时间，我就长话短说（偷懒找个借口:p）。<strong>这个算法是干嘛的？</strong>它解决的问题是，给定一个字符串，我们称之为主角K，然后你要在一个比它长的配角Z中找到我们的主角。翻译一下：在父串中寻找给定的子串，返回匹配索引。比如说<code>K = king</code>，<code>Z = zookingmonkey</code>，很显然，Z中有与K相同的子串，返回索引<code>4</code>.</p>
<h2 id="常规方法"><a href="#常规方法" class="headerlink" title="常规方法"></a>常规方法</h2><p>沿用Jake Boxer的例子，设<code>K = abababca</code>，<code>Z = bacbababaabcbab</code>. 常规的方法是从头开始比较，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * `|` denotes a match</span><br><span class="line"> * `x` denotes a dismatch</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">(1):</span><br><span class="line">bacbababaabcbab</span><br><span class="line">x</span><br><span class="line">abababca</span><br><span class="line"></span><br><span class="line">(2):</span><br><span class="line">bacbababaabcbab</span><br><span class="line"> |x</span><br><span class="line"> abababca</span><br><span class="line"></span><br><span class="line">(3):</span><br><span class="line">bacbababaabcbab</span><br><span class="line">  x</span><br><span class="line">  abababca</span><br><span class="line"></span><br><span class="line">(4):</span><br><span class="line">bacbababaabcbab</span><br><span class="line">   x</span><br><span class="line">   abababca</span><br><span class="line"></span><br><span class="line">(5):</span><br><span class="line">bacbababaabcbab</span><br><span class="line">    |||||x</span><br><span class="line">    abababca</span><br><span class="line"></span><br><span class="line">(6):</span><br><span class="line">bacbababaabcbab</span><br><span class="line">     x</span><br><span class="line">     abababca</span><br><span class="line"></span><br><span class="line">(7):</span><br><span class="line">bacbababaabcbab</span><br><span class="line">      |||x</span><br><span class="line">      abababca</span><br><span class="line"></span><br><span class="line">(8):</span><br><span class="line">bacbababaabcbab</span><br><span class="line">       x</span><br><span class="line">       abababca</span><br><span class="line"></span><br><span class="line">(9):</span><br><span class="line">bacbababaabcbab|</span><br><span class="line">               |</span><br><span class="line">        abababca</span><br><span class="line"></span><br><span class="line">---&gt; return NOT FOUND!</span><br></pre></td></tr></table></figure></p>
<p>以上就是正常思考的方法，维护一个指针<code>p</code>，指向第一次开始比的位置，然后依次比下去， 跟踪匹配的位数 ，如果全部匹配，返回<code>p</code>，如果有一个不匹配，直接右移一位，<code>p = p+1</code>. 接着如法炮制，从第一个字符依次比下去。设父串Z的长度为 <code>n</code>，子串K的长度为<code>m</code>，那么上述方法最坏情况下要比较<code>m*n</code>次，时间复杂度为<code>O(mn)</code>.</p>
<p>KMP算法要做的事情的，就是根据子串K的特征，在<strong>移位</strong>和<strong>比较</strong>的时候实现一个跳步！减少了比较次数。</p>
<p>但是要根据子串K的特征，哪又是什么样的？该如何刻画呢？这就要说到下面的 partial match table 了。</p>
<h2 id="Partial-Match-Table"><a href="#Partial-Match-Table" class="headerlink" title="Partial Match Table"></a>Partial Match Table</h2><p>KMP有一个很重要的表，叫做 Partial Match Table (PMT)，翻译过来叫做部分匹配表。它有多重要呢？就像理想对于你的那种重要。KMP什么时候能跳步，跳多少，都是由它决定的！</p>
<p>先来看看它如何产生的吧，关于它的生成，许多博文讲得很清楚了。其中大多是用前缀集、后缀集的概念描述。设有字符串<code>str = ababba</code>, 它的长度<code>length(str) = 6</code>,</p>
<ul>
<li><strong>前缀集</strong>：去掉字符串尾部 1-5 个字符得到的所有子串。记作 <code>P(str)</code> = {a, ab, aba, abab, ababb}.</li>
<li><strong>后缀集</strong>：去掉字符串头部 1-5 个字符得到的所有子串。记作 <code>S(str)</code> = {a, ba, bba, abba, babba}.</li>
</ul>
<p>该字符串<code>str = ababba</code>对应的 partial mathch value (PMV) 计算方式：</p>
<script type="math/tex; mode=display">
v = \max_{i\in S(\texttt{str}) \cap P(\texttt{str})} \text{length}(i) := f(\texttt{str})</script><p>于是，给定一个字符串<code>str</code>，我们的<code>f(str)</code>就能返回它的PMV. 现在有请我们的主角<code>K = abababca</code>上场，我们来看看如何构建它的PMT.</p>
<blockquote>
<p>Note: 为了防止我自定义的术语让你感到很吃力，先给你洗个脑。<br>PMT 是一个表（table）， PMV 是一个值（value）。PMT中的元素就是PMV.<br>PMT 是一个表（table）， PMV 是一个值（value）。PMT中的元素就是PMV.<br>PMT 是一个表（table）， PMV 是一个值（value）。PMT中的元素就是PMV.</p>
</blockquote>
<p>先用一句话简要说明一下：对K的前缀集的每个字符串再加上K本身，计算它们的PMV，按从短到长的顺序将它们排成一行。再用程序语言表达一下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildPMT</span><span class="params">(K)</span>:</span></span><br><span class="line">    <span class="comment"># 假设 S(K) 返回的列表按子串的长度从小到大排序</span></span><br><span class="line">    PMT = [f(substr) <span class="keyword">for</span> substr <span class="keyword">in</span> S(K)]</span><br><span class="line">    PMT.append(f(K))</span><br><span class="line">    <span class="keyword">return</span> PMT</span><br></pre></td></tr></table></figure></p>
<p>那么我们计算得到的<code>K = abababca</code>的 partial match table 如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:right">str</th>
<th style="text-align:center">a</th>
<th style="text-align:center">b</th>
<th style="text-align:center">a</th>
<th style="text-align:center">b</th>
<th style="text-align:center">a</th>
<th style="text-align:center">b</th>
<th style="text-align:center">c</th>
<th style="text-align:center">a</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">value</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:right">index</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
</tr>
</tbody>
</table>
</div>
<p>记住这个表，它很重要！或者讲到跳转的时候再过来查看。这一部分基本上是转述了Jake Boker的话，不过表达的可能不如他。感谢Jake Boxer.</p>
<h3 id="又"><a href="#又" class="headerlink" title="又"></a>又</h3><p>下面讲讲我理解的PMT的计算方式。因为PMV (partial match value) 是最大公共子串的长度，哪两个公共？前缀集和后缀集！那么我们比较的时候肯定要分别在两个集合中找字符串长度一致的两个串，考察它们是否相等。依次从长度为1，2，3…这么一直找下去，如果有更长的公共串，就更新PMV。</p>
<p>具体来说，给我一个字符串<code>str = ababa</code>，我可以这样来计算它的PMV. 想象有一块木板插空该字符串，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a|baba =&gt; a, baba</span><br><span class="line">ab|aba =&gt; ab, aba</span><br><span class="line">aba|ba =&gt; aba, ba</span><br><span class="line">abab|a =&gt; abab, a</span><br></pre></td></tr></table></figure></p>
<p>每次插空，我都可以得到一个前缀和一个后缀。从上面的结果来看，产生的次序还有一定的对称性。那么我计算它的PMV时，直接这样比较：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1). a|baba &lt;=&gt; abab|a ---&gt; PMV = 1</span><br><span class="line">(2). ab|aba &lt;=&gt; aba|ba ---&gt; PMV = 3</span><br><span class="line">( ). aba|ba &lt;=&gt; ab|aba ---&gt; it returns to step (2)</span><br><span class="line">( ). abab|a &lt;=&gt; a|baba ---&gt; it returns to step (1)</span><br><span class="line"></span><br><span class="line">---&gt; return PMV = 3</span><br></pre></td></tr></table></figure></p>
<p>即每次划分之后，我直接考察它对称的划分，然后比较前缀后缀是否相等，进而更新PMV.</p>
<h2 id="PMT-怎么用"><a href="#PMT-怎么用" class="headerlink" title="PMT 怎么用"></a>PMT 怎么用</h2><p>实际上这一段也算是转述Jake Boxer的话，再次感谢！</p>
<blockquote>
<p>KMP算法要做的事情的，就是根据子串K的特征，在<strong>移位</strong>和<strong>比较</strong>的时候实现一个跳步！减少了比较次数。</p>
</blockquote>
<p>之前提到KMP的主要思想就是跳步，现在是时候来看看它是怎么个跳法了。同样的父串<code>Z = bacbababaabcbab</code>，子串<code>K = abababca</code>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * `|` denotes a match</span><br><span class="line"> * `x` denotes a dismatch</span><br><span class="line"> * `~` denotes a jump</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">(1):</span><br><span class="line">bacbababaabcbab</span><br><span class="line">x</span><br><span class="line">abababca</span><br><span class="line"></span><br><span class="line">(2):</span><br><span class="line">bacbababaabcbab</span><br><span class="line"> |x</span><br><span class="line"> abababca</span><br><span class="line"></span><br><span class="line">(3):</span><br><span class="line">bacbababaabcbab</span><br><span class="line">  x</span><br><span class="line">  abababca</span><br><span class="line"></span><br><span class="line">(4):</span><br><span class="line">bacbababaabcbab</span><br><span class="line">   x</span><br><span class="line">   abababca</span><br><span class="line"></span><br><span class="line">(5):</span><br><span class="line">bacbababaabcbab</span><br><span class="line">    |||||x</span><br><span class="line">    abababca</span><br><span class="line">!ATTENTION! I&apos;LL JUMP</span><br><span class="line"></span><br><span class="line">(6):</span><br><span class="line">bacbababaabcbab</span><br><span class="line">    ~~|||x</span><br><span class="line">      abababca</span><br><span class="line">!JUMP AGAIN!</span><br><span class="line"></span><br><span class="line">(7):</span><br><span class="line">bacbababaabcbab|</span><br><span class="line">      ~~       |</span><br><span class="line">        abababca</span><br><span class="line"></span><br><span class="line">---&gt; return NOT FOUND!</span><br></pre></td></tr></table></figure></p>
<p>为什么你跳得这么兴奋？为什么可以这么跳？我想应该有人和我当初一样，虽然你跳的很好，但是我一脸懵逼(＃°Д°). </p>
<p>我们把来看step5到step6的跳步拎出来看看，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(5):</span><br><span class="line">bacbababaabcbab</span><br><span class="line">    |||||x</span><br><span class="line">    abababca</span><br><span class="line"></span><br><span class="line">(5.1):</span><br><span class="line">****ababa******</span><br><span class="line">    |||||x</span><br><span class="line">    ababa***</span><br></pre></td></tr></table></figure></p>
<p>从step5到step5.1我什么也没干，只是把一些碍眼的东西替换成了<code>*</code>号。我们可以看到的是，step5匹配了5个字符，匹配的是K的开头向后5个字符。让我们回头看看这个子串的PMV，查表得知<code>f(&quot;ababa&quot;)=3</code>. 这个“3”代表着什么？它代表了子串<code>ababa</code>的长度为3的前缀一定等于长度为3的后缀，因为这就是PMV的物理意义啊，同志们！所以我可以跳步！直接将前缀<code>abc</code>挪到与后缀<code>abc</code>对齐！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aba|ba &lt;=&gt; ab|aba</span><br><span class="line"></span><br><span class="line">---&gt; jump:</span><br><span class="line"></span><br><span class="line">ababa</span><br><span class="line">~~|||</span><br><span class="line">  ababa</span><br></pre></td></tr></table></figure></p>
<p>我不但可以跳步2，我还知道后面的3个字符比都不用比，肯定和父串match，所以我直接从第4个字符开始比。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(5):</span><br><span class="line">bacbababaabcbab</span><br><span class="line">    |||||x</span><br><span class="line">    abababca</span><br><span class="line"></span><br><span class="line">(5.1):</span><br><span class="line">****ababa******</span><br><span class="line">    |||||x</span><br><span class="line">    ababa***</span><br><span class="line"></span><br><span class="line">(6):</span><br><span class="line">bacbababaabcbab</span><br><span class="line">    ~~|||x</span><br><span class="line">      abababca</span><br><span class="line">         |</span><br><span class="line">         start point for comparison</span><br></pre></td></tr></table></figure></p>
<p>如果将PMT存在一个数组里，数组下表从0开始的话，那么每次跳步的长度就可以用一个公式来刻画：</p>
<p><div style="text-align:center">
    <code>
        jump_chars = PML - PMT[PML-1]
    </code>
</div><br>其中，PML 表示 partial match length，代表当前匹配长度，比如step5的匹配长度 <code>PML=5</code>.</p>
<p>Q: PMT是什么？它为什么这么屌？凭什么它这么屌？它是干嘛的呢？<br>A: 可以说PMT就是待匹配字符串的本体了。</p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>来日在填(╬ Ò ‸ Ó)</p>
<h2 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h2><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/" target="_blank" rel="noopener">The Knuth-Morris-Pratt Algorithm in my own words</a></li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:guyueshui002@gmail.com">Yychi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://guyueshui.github.io/2019/04/04/瞎说KMP算法/">https://guyueshui.github.io/2019/04/04/瞎说KMP算法/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/algorithm/">algorithm</a><a class="post-meta__tags" href="/tags/pattern-match/">pattern match</a><a class="post-meta__tags" href="/tags/string-match/">string match</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://s2.ax1x.com/2019/01/18/k9S5a6.png"><div class="post-qr-code__desc">微信：我很贫穷(*/ω＼*)</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://s2.ax1x.com/2019/01/18/k9SvZt.jpg"><div class="post-qr-code__desc">支付宝：请给我钱(╬ Ò ‸ Ó)</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/04/07/动态规划初体验/"><i class="fa fa-chevron-left">  </i><span>动态规划初体验</span></a></div><div class="next-post pull-right"><a href="/2019/04/02/初尝-C-类设计/"><span>初尝 C++ 类设计</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.ax1x.com/2019/02/19/kgD6g0.png)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By Yychi</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Work with <font color="#ffb3d1"><i class="fa fa-heartbeat fa-lg"> </i></font> by yychi</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.0"></script><script src="/js/fancybox.js?version=1.6.0"></script><script src="/js/sidebar.js?version=1.6.0"></script><script src="/js/copy.js?version=1.6.0"></script><script src="/js/fireworks.js?version=1.6.0"></script><script src="/js/transition.js?version=1.6.0"></script><script src="/js/scroll.js?version=1.6.0"></script><script src="/js/head.js?version=1.6.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"scale":0.7,"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":70,"height":180},"mobile":{"show":false,"scale":0.5},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>