<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="初尝 C++ 类设计"><meta name="keywords" content="c++"><meta name="author" content="Yychi,guyueshui002@gmail.com"><meta name="copyright" content="Yychi"><title>初尝 C++ 类设计 | 水阙</title><link rel="shortcut icon" href="/cali.png"><link rel="stylesheet" href="/css/index.css?version=1.6.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.0"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?a37e52e4ac68b7bedc09537444f68899";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-132747551-1', 'auto');
ga('send', 'pageview');</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Definitions"><span class="toc-number">1.</span> <span class="toc-text">Definitions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Implementions"><span class="toc-number">2.</span> <span class="toc-text">Implementions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数的实现"><span class="toc-number">2.1.</span> <span class="toc-text">构造函数的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转换函数的实现"><span class="toc-number">2.2.</span> <span class="toc-text">转换函数的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://guyueshui.github.io/assets/avatar.png"></div><div class="author-info__name text-center">Yychi</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">33</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">34</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">3</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://ruanzz.github.io">Ryan's Blog</a><a class="author-info-links__name text-center" href="http://www.matrix67.com/blog/">Matrix67</a><a class="author-info-links__name text-center" href="/links">More...</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s2.ax1x.com/2019/02/19/kgD6g0.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">水阙</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/sketch">札记</a><a class="site-page" href="/tricks">Tricks</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">初尝 C++ 类设计</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-02</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Learning-Notes/">Learning Notes</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>最近在准备笔试，于是在各种网站上刷题嘛。期间做了百度某年的一道<a href="http://exercise.acmcoder.com/online/online_judge_ques?ques_id=3821&amp;konwledgeId=40" target="_blank" rel="noopener">编程题</a>。</p>
<blockquote>
<p>小B最近对电子表格产生了浓厚的兴趣，她觉得电子表格很神奇，功能远比她想象的强大。她正在研究的是单元格的坐标编号，她发现表格单元一般是按列编号的，第1列编号为A，第2列为B，以此类推，第26列为Z。之后是两位字符编号的，第27列编号为AA，第28列为AB，第52列编号为AZ。之后则是三位、四位、五位……字母编号的，规则类似。</p>
<p>表格单元所在的行则是按数值从1开始编号的，表格单元名称则是其列编号和行编号的组合，如单元格BB22代表的单元格为54列中第22行的单元格。</p>
<p>小B感兴趣的是，编号系统有时也可以采用RxCy的规则，其中x和y为数值，表示单元格位于第x行的有第y列。上述例子中的单元格采用这种编码体系时的名称为R22C54。</p>
<p>小B希望快速实现两种表示之间的转换，请你帮忙设计程序将一种方式表示的坐标转换为另一种方式。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>输入</th>
<th>输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入的第一行为一个正整数T，表示有T组测试数据（<code>1&lt;=T&lt;=10^5</code>）。随后的T行中，每行为一组测试数据，为一种形式表示的单元格坐标。保证所有的坐标都是正确的，且所有行列坐标值均不超过10^6</td>
<td>对每组测试数据，单独输出一行，为单元格坐标的另一种表示形式。</td>
</tr>
<tr>
<td>2 <br> R23C55 <br> BC23</td>
<td>BC23 <br> R23C55</td>
</tr>
</tbody>
</table>
</div>
</blockquote>
<p>写这道题目的时候，正好复习了C++的类，于是居然鬼使神差的想设计一个类来实现它。C++的核心思想是面向对象，而此处的单元格正好有显著的对象特征。一个单元格，应该有座标，以及其中的内容。这是很自然的，当初看C++ Primer的时候，书中也是以书本销量作为引入，介绍并阐述类的设计。</p>
<h2 id="Definitions"><a href="#Definitions" class="headerlink" title="Definitions"></a>Definitions</h2><p>闲话少说，现在就来看看如何实现这个类。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unit/Unit.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Unit</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> pos = <span class="keyword">unsigned</span> <span class="keyword">int</span>;</span><br><span class="line">    pos rowIdx;</span><br><span class="line">    pos colIdx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// constructors</span></span><br><span class="line">    Unit(pos _r, pos _c) : rowIdx(_r), colIdx(_c) &#123; &#125;</span><br><span class="line">    <span class="comment">// constructor2</span></span><br><span class="line">    Unit(<span class="built_in">string</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>先看这么多，我希望每个单元个有两个属性，一个行索引<code>rowIdx</code>一个列索引<code>colIdx</code>. 而且我定义了两个构造函数，一个是直接将行列索引传入，另一个则是通过读取一个字符串，来解析出其中的行列索引的值。这里有一个问题，因为不同类型的字符串解析的方式不一样，所以需要一个指示变量来指明传入的字符串到底是哪个类型：<code>BC23</code>还是<code>R23C55</code>？除此之外，我还需要一个可以转换不同类型表示的函数，给了我表示类型1，我可以直接调用一个函数，输出表示类型2. 需求先大致到这里，来改进一下之前的类。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unit/Unit.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _UNIT_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _UNIT_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Unit</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> pos = <span class="keyword">unsigned</span> <span class="keyword">int</span>; <span class="comment">// type alias</span></span><br><span class="line">    pos rowIdx;</span><br><span class="line">    pos colIdx;</span><br><span class="line">    <span class="keyword">bool</span> isRC; <span class="comment">// is the type `R23C55`?</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getIdx_RC</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>)</span></span>; <span class="comment">// build index for type 'R23C55'</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getIdx_NRC</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>)</span></span>; <span class="comment">// for type 'BC23'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// constructor1</span></span><br><span class="line">    Unit(pos _r, pos _c) : rowIdx(_r), colIdx(_c) &#123; &#125;</span><br><span class="line">    <span class="comment">// constructor2</span></span><br><span class="line">    Unit(<span class="built_in">std</span>::<span class="built_in">string</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// selectors</span></span><br><span class="line">    <span class="function">pos <span class="title">getRow</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> rowIdx; &#125;</span><br><span class="line">    <span class="function">pos <span class="title">getCol</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> colIdx; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// modifiers</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRow</span><span class="params">(pos _r)</span> </span>&#123; rowIdx = _r; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCol</span><span class="params">(pos _c)</span> </span>&#123; colIdx = _c; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// utilties</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printer</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">convertor</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>这里先不要纠结定义了很多不知道要干嘛的函数，往下看类的实现，你会慢慢明白为什么需要它们。</p>
<h2 id="Implementions"><a href="#Implementions" class="headerlink" title="Implementions"></a>Implementions</h2><p>类的头文件中只定义了类，除少数内联函数外，大多数函数仍未实现。按照模块化的哲学，新开一个文件写类的实现。</p>
<h3 id="构造函数的实现"><a href="#构造函数的实现" class="headerlink" title="构造函数的实现"></a>构造函数的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unit/Unit.hpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Unit.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// implement constructor2</span></span><br><span class="line">Unit::Unit(<span class="built_in">string</span> _s) &#123;</span><br><span class="line">    <span class="comment">// wishful thinking </span></span><br><span class="line">    isRC = typeInfer(_s);</span><br><span class="line">    <span class="keyword">if</span> (isRC) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * wishful thinking: suppose i have the function</span></span><br><span class="line"><span class="comment">     * that helps me do this job</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        getIdx_RC(_s);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// again wishful thinking</span></span><br><span class="line">        getIdx_NRC(_s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，现在我们实现了第二个构造函数，它接受一个<code>string</code>对象，从中解析出行列索引的值，然后初始化<code>rowIdx</code>和<code>colIdx</code>. </p>
<p>但是，我们想当然的调用了一些我们还没有实现的函数。这里要特别注意一点：在写程序的时候，这种想法很有用！以下思想来自我学习<a href="https://mitpress.mit.edu/sites/default/files/sicp/index.html" target="_blank" rel="noopener">SICP</a>一段时间以后的自我体会：程序往往会包含很多的函数，为什么？因为有时候一个稍微复杂的问题，并不是一个函数就能解决的，所以需要多个函数相互协调，相互调用才能共同完成或是解决一项工作。如果你费尽心思把它们都写在一个函数里，可能你觉得很好，但是一旦程序报错，你将无从下手，很难定位到错误发生在哪里。这也是程序设计讲究模块化的理由。将复杂的功能抽象成一个一个的互不干涉的模块（子程序），在每一个小模块里尽可能的将代码写好，使得它只完成并且高效准确地完成这一项任务。那么当所有模块相互协同起来，将会使难以想象的高效，且不容易出错，即便是出错了，也能很快定位到错误发生的地点，便于调试。</p>
<p>这样做的好处还有一个，就是你在写程序的时候变得更加轻松。为什么？因为我不用考虑所有的细节，只是调用了一些函数，而实现这些函数很可能不是我们要干的活。<q>Oh, that’s cool! George will do for me.</q> 你甚至可以去喝杯咖啡。但是现在，让我们短暂的充当以下 George 的角色。就拿<code>Unit</code>类的设计来说，我现在想要实现第二个构造函数，根据题目的意思，我可能接受两个代表不同表示方法的<code>string</code>，我要将它们解析成行列索引。让我们回头看看这个函数的实现，它先判断输入的是那个类型，然后分情况做不同的事（调用不同的函数）。这里我用到了3个wishful thinking：</p>
<ol>
<li>我希望有一个叫<code>typeInfer()</code>的函数，我给它一个字符串，它告诉我这属于哪个类型的表示方法。</li>
<li>如果是<code>RxCy</code>型，我希望有一个函数<code>getIdx_RC()</code>能够处理这种类型的输入，解析出行列索引。</li>
<li>如果是<code>BC23</code>型，我希望有一个函数<code>getIdx_NRC()</code>能够处理这种类型的输入，解析出行列索引。</li>
</ol>
<p>这样一来，我们不容易犯错。为什么？因为这个构造函数的逻辑足够简单，仅仅是分两个情况做不同的事。做的事也很简单：仅仅是调用一个函数！如果你能保证所调用的函数不犯错，那么整个过程也不会出错。既简单，又robust！</p>
<p>还有我个人认为的好处就是，写程序变得简单了。我到每一步的时候，需要什么，想象一下，假设它已经有了，我该怎么写，怎么去调用它。这样你就对为什么要有这个函数，以及这个函数要干什么，心知肚明了。然后上层建设好之后，我再去考虑如何实现那些想象！现在，我们来看看，之前想当然的几个函数如何实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unit/Unit.hpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Unit.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Predefined things...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">typeInfer</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> _s)</span> </span>&#123; <span class="comment">// infer the representation type</span></span><br><span class="line">    <span class="keyword">if</span> (_s[<span class="number">0</span>] == <span class="string">'R'</span> &amp;&amp; <span class="built_in">std</span>::<span class="built_in">isdigit</span>(_s[<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Unit::getIdx_RC(<span class="built_in">std</span>::<span class="built_in">string</span> _s) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * build the row/col index for</span></span><br><span class="line"><span class="comment">     * type 'R23C55'</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    _s.erase(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// remove first 'R'</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// find where 'C' is</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>::size_type c_pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; c_pos != _s.size(); ++c_pos) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_s[c_pos] == <span class="string">'C'</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> s1 = _s.substr(<span class="number">0</span>, <span class="number">0</span> + c_pos); <span class="comment">// s1 = "23"</span></span><br><span class="line">    <span class="keyword">auto</span> s2 = _s.substr(c_pos + <span class="number">1</span>, _s.size()); <span class="comment">// s2 = "55"</span></span><br><span class="line">    <span class="comment">// set index</span></span><br><span class="line">    rowIdx = <span class="built_in">std</span>::stoi(s1);</span><br><span class="line">    colIdx = <span class="built_in">std</span>::stoi(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Unit::getIdx_NRC(<span class="built_in">std</span>::<span class="built_in">string</span> _s) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * build the row/col index for</span></span><br><span class="line"><span class="comment">     * type 'BC23'</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the first num</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>::size_type n_pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; n_pos != _s.size(); ++n_pos) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">isdigit</span>(_s[n_pos]))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> s1 = _s.substr(<span class="number">0</span>, n_pos); <span class="comment">// s1 should be "BC"</span></span><br><span class="line">    <span class="keyword">auto</span> s2 = _s.substr(n_pos, _s.size()); <span class="comment">// s2 should be "23"</span></span><br><span class="line">    rowIdx = <span class="built_in">std</span>::stoi(s2);</span><br><span class="line">    colIdx = letter2pos(s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Note: 注意到<code>getIdx_RC()</code>和<code>getIdx_NRC()</code>需要访问类内私有变量，所以应该声明成类的成员函数。</p>
</blockquote>
<p>好了，看了上面的实现，我又想当然的引入了几个函数。但是通过上下文，你可以很明显的看出来我引入这个函数实干嘛用的。正是因为这个时候我需要有一个函数帮我去干这个事情，而我又不想把这些复杂的工作都写到一个函数里面（因为容易出错，且很难调试）。所以我引入了它们：</p>
<ol>
<li><code>letter2pos()</code>接受一个字符串，返回解析出来的数值索引。</li>
</ol>
<p>好吧，居然只引入了一个(╬ Ò ‸ Ó)，再来看看它的实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unit/Unit.hpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Predefined things...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// return the corresponding num for a given string</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">letter2pos</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; _s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> len = _s.size();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; len != <span class="number">0</span>; --len) &#123;</span><br><span class="line">        res = res*<span class="number">26</span> + alph2num(_s[_s.size() - len]);</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; "res: " &lt;&lt; res &lt;&lt; std::endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return the corresponding string for a given num</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">pos2letter</span><span class="params">(<span class="keyword">int</span> _p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_p &lt;= <span class="number">26</span>)&#123;</span><br><span class="line">        <span class="keyword">char</span> c[<span class="number">1</span>] = &#123;num2alph(_p)&#125;;</span><br><span class="line">        <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(c)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (_p &gt; <span class="number">26</span>) &#123;</span><br><span class="line">        r = _p%<span class="number">26</span>;</span><br><span class="line">        res += num2alph(r);</span><br><span class="line">        _p /= <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res += num2alph(_p);</span><br><span class="line">    <span class="built_in">std</span>::reverse(res.begin(), res.end());</span><br><span class="line">    <span class="comment">// cout &lt;&lt; "res: " &lt;&lt; res &lt;&lt; endl; </span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>哈哈，我又想象了几个不存在的函数。它们的作用很容易通过上下文得知。<code>letter2pos()</code>和<code>pos2letter()</code>是一对相反的函数，它们的作用是完成<code>BC&lt;-&gt;55</code>的映射。至于<code>alph2num()</code>和<code>num2alph()</code>，其实也是一对相反的函数，用于检索26个字母对应的数值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unit/Unit.hpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// global map for quick search</span></span><br><span class="line"><span class="keyword">char</span> MAP[<span class="number">26</span>] = &#123;<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>,<span class="string">'G'</span>,</span><br><span class="line">                <span class="string">'H'</span>,<span class="string">'I'</span>,<span class="string">'J'</span>,<span class="string">'K'</span>,<span class="string">'L'</span>,<span class="string">'M'</span>,<span class="string">'N'</span>,</span><br><span class="line">                <span class="string">'O'</span>,<span class="string">'P'</span>,<span class="string">'Q'</span>,<span class="string">'R'</span>,<span class="string">'S'</span>,<span class="string">'T'</span>,</span><br><span class="line">                <span class="string">'U'</span>,<span class="string">'V'</span>,<span class="string">'W'</span>,<span class="string">'X'</span>,<span class="string">'Y'</span>,<span class="string">'Z'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return a num for the given char</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alph2num</span><span class="params">(<span class="keyword">char</span> _c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; idx != <span class="number">26</span>; ++idx) &#123;</span><br><span class="line">        <span class="keyword">if</span> (MAP[idx] == _c)</span><br><span class="line">            <span class="keyword">return</span> idx + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; _c &lt;&lt; <span class="string">"Not found!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return a char for the given num</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">num2alph</span><span class="params">(<span class="keyword">int</span> _i)</span> </span>&#123; <span class="keyword">return</span> MAP[_i - <span class="number">1</span>]; &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="转换函数的实现"><a href="#转换函数的实现" class="headerlink" title="转换函数的实现"></a>转换函数的实现</h3><p>基于上面的工作，转换函数的实现就显得格外清晰简单。所谓转换函数，就是当我输入的是类型1的字符串，它输出转换之后的类型2的字符串，由此达到一个转换单元格表示方法的效果。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unit/Unit.hpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Predefined things...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Unit::convertor() &#123;</span><br><span class="line">    <span class="keyword">if</span> (isRC) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pos2letter(colIdx)</span><br><span class="line">            + <span class="built_in">std</span>::to_string(rowIdx) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"R"</span></span><br><span class="line">            + <span class="built_in">std</span>::to_string(rowIdx)</span><br><span class="line">            + <span class="string">"C"</span></span><br><span class="line">            + <span class="built_in">std</span>::to_string(colIdx) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Unit::printer() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"row index: "</span> &lt;&lt; rowIdx</span><br><span class="line">        &lt;&lt; <span class="string">"\ncol index: "</span> &lt;&lt; colIdx &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后附加一个<code>printer()</code>方便打印信息。至此，整个类的设计大概就完了。值得注意的是，最后的<code>convertor()</code>之所以能够如此简单地写出来，是因为我们合理将一些工作模块化，这样带来的好处就是可以重复利用，易于维护。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我之前写代码，总是不注意模块化，不注意抽象化。能一个函数完成的事为什么要写两个函数？然而，最后只能自食其果。一旦报错，一步步地定位错误，从下往上调试，陷入苦海。也有的时候，因为函数过于复杂，把自己绕糊涂，陷入一个圈子里想不通，弄不懂，出不来。这些结果都以失败告终！而且会打击自信心，感觉别人写代码是写代码，我写代码就纯粹是写bug啊！</p>
<p>好在前段时间看了点SICP，B站上有视频的，我自己也在对着书看，真的是非常好的课程。循着书中传递的思想，慢慢就这么写着，发现有的问题可以写出来了，得益于代码结构的改变，调试错误也比以前稍微轻松一些。到这次写这道编程题，要是在考试中这么写，我肯定来不及的。但是我在课余花了不少时间构思，终于用面向对象的思想将它初步实现。虽然这个类设计的很简单，也有很多瑕疵：</p>
<ol>
<li>异常输入的处理</li>
<li>类结构的优化以及完备性检查</li>
<li>代码细节的优化</li>
</ol>
<p>但是和以前半途而废相比，起码完成了类的实现，虽然很粗糙。谨以此文记录一下！</p>
<p><strong>附赠：SICP的学习资源</strong></p>
<ol>
<li><a href="https://www.bilibili.com/video/av8515129" target="_blank" rel="noopener">B站视频</a></li>
<li><a href="https://sarabander.github.io/sicp/" target="_blank" rel="noopener">在线电子书</a></li>
<li><a href="http://community.schemewiki.org/?SICP-Solutions" target="_blank" rel="noopener">习题答案</a></li>
<li><a href="https://github.com/sarabander/p2pu-sicp" target="_blank" rel="noopener">p2pu sicp solutions</a></li>
</ol>
<font color="red">感谢SICP视频翻译工作者，感谢B站up主的搬运，感谢开源社区！</font>

</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:guyueshui002@gmail.com">Yychi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://guyueshui.github.io/2019/04/02/初尝-C-类设计/">https://guyueshui.github.io/2019/04/02/初尝-C-类设计/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/c/">c++</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://s2.ax1x.com/2019/01/18/k9S5a6.png"><div class="post-qr-code__desc">微信：我很贫穷(*/ω＼*)</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://s2.ax1x.com/2019/01/18/k9SvZt.jpg"><div class="post-qr-code__desc">支付宝：请给我钱(╬ Ò ‸ Ó)</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/04/04/瞎说KMP算法/"><i class="fa fa-chevron-left">  </i><span>瞎说 KMP 算法</span></a></div><div class="next-post pull-right"><a href="/2019/03/26/LeetCode-Sum-of-Two-Integers/"><span>LeetCode: Sum of Two Integers</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.ax1x.com/2019/02/19/kgD6g0.png)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By Yychi</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Work with <font color="#ffb3d1"><i class="fa fa-heartbeat fa-lg"> </i></font> by yychi</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.0"></script><script src="/js/fancybox.js?version=1.6.0"></script><script src="/js/sidebar.js?version=1.6.0"></script><script src="/js/copy.js?version=1.6.0"></script><script src="/js/fireworks.js?version=1.6.0"></script><script src="/js/transition.js?version=1.6.0"></script><script src="/js/scroll.js?version=1.6.0"></script><script src="/js/head.js?version=1.6.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"scale":0.7,"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":70,"height":180},"mobile":{"show":false,"scale":0.5},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>